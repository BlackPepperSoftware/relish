#+TITLE: Relish Tutorial

#+ATTR_HTML: :alt Logo :title Relish logo :align right
#+ATTR_HTML: :width 75px :height 108px
[[../images/Relish.png]]

* Introduction

In this tutorial, we'll go through the steps required to create a Relish test suite for a simple task management application.

* Creating a project

For the details see [[./creatingProject.html][here]]

* Create our tests

We're going to create an application that will allow a user to create, read, update and delete tasks. Let's say this is our first user story:

#+BEGIN_QUOTE
*Story 1: A list of tasks can be managed by the application*

As a user

I want to be able to create, read, update and delete tasks

So that I can manage my time
#+END_QUOTE

We'll create a new Cucumber =feature= file in the =src/resources/features/= folder called =0001-can-manage-list-of-tasks.feature=

#+BEGIN_SRC feature
Feature: A list of tasks can be managed by the application
  As a user
  I want to be able to create, read, update and delete tasks
  So that I can manage my time
#+END_SRC

Now we'll add our first scenario--a test that checks that when the app is first started, that there are no tasks recorded. When we write the application, we'll expect the main page to look something like this:

[[images/notasks.png]]

We can write a scenario to check that this is true:

#+BEGIN_SRC feature
Feature: A list of tasks can be managed by the application
  As a user
  I want to be able to create, read, update and delete tasks
  So that I can manage my time

  Scenario: Initially the list of tasks is empty
    Given I am on the task list
    Then the list of tasks will be empty
#+END_SRC

This scenario contains two steps:

# Given I am on the task list
# Then the list of tasks will be empty

We'll need to write methods for each of these in the =SomeSteps.java= file that will automate the application for us.

And this is where Relish finally makes an appearance...

* Introducing Relish components

What we /could/ do at this point, is write a couple of methods that will use Selenide or Selenium code to automate the browser. And the code to launch the app and go to the task list page, then check that a table is empty probably won't be that long. But the trouble is that we are likely to interact with the same components and pages multiple times as we create more and more scenarios.

And that's where Relish helps. Relish allows you to quickly build testing components that represent the various elements of your UI, and allows you to interact with them in a simpler and more re-usable way.

** Launching the front page

Let's begin with the first step: 'Given I am on the task list'. We'll create a Relish /Page/ class that represents the main page of our app:

#+BEGIN_SRC java
  package com.example.components;

  import uk.co.blackpepper.relish.selenide.Page;

  public class TaskPage extends Page
  {
      public TaskPage()
      {
          super("/index.html");
      }
  }
#+END_SRC

This =TaskPage= is a testing facade that represents the front page of our application. Any kind of interaction we make with the =index.html= page, we'll make through this object. We'll need to construct a =TaskPage= object in our =SomeSteps.java= file, which we can then use in the 'Given I am on the task list' step:

#+BEGIN_SRC java
  package com.example.steps;

  import com.example.components.TaskPage;

  import cucumber.api.java.en.Given;

  public class SomeSteps
  {
      private TaskPage taskPage = new TaskPage();

      @Given("^I am on the task list$")
      public void iAmOnTheTaskList()
      {
          taskPage.launch();
      }
  }
#+END_SRC

Because the =TaskPage= extends the Relish =Page= class, it automatically knows how to contact the web driver and launch the correct URL.

** Checking that the table is empty

Now we need to check that the table on the front page is empty. Again, we could just write some Selenide code in the step method in =SomeSteps=, but instead we will simply tell the =TaskPage= that it will contain a table for the tasks:

#+BEGIN_SRC java
  package com.example.components;

  import org.openqa.selenium.By;

  import uk.co.blackpepper.relish.selenide.Table;
  import uk.co.blackpepper.relish.selenide.Page;

  public class TaskPage extends Page
  {
      public TaskPage()
      {
          super("/index.html");
      }

      public Table taskTable()
      {
          return new Table(By.className("tasks"), this);
      }
  }
#+END_SRC

The =taskTable()= method of the page returns a Relish object that represents the =Table= object that will be on the front screen. When we construct Relish web components, we need to provide two pieces of information:

# Either a =SelenideElement= representing the component, or (as here) a Selenium =By= selector that will find the element
# A Relish parent component. Here the parent of the table, is the page object.

Now that we have a =taskTable()= for our page, how do we use it? Let's add the implementation for our second step:

#+BEGIN_SRC java
  package com.example.steps;

  import com.example.components.TaskPage;

  import cucumber.api.java.en.Given;
  import cucumber.api.java.en.Then;

  public class SomeSteps
  {
      private TaskPage taskPage = new TaskPage();

      @Given("^I am on the task list$")
      public void iAmOnTheTaskList()
      {
          taskPage.launch();
      }

      @Then("^the list of tasks will be empty$")
      public void theListOfTasksWillBeEmpty()
      {
          taskPage.taskTable().assertEmpty();
      }
  }

#+END_SRC

The =Table= object will look at the number of rows in the table that contain actual data (<td> cells) and checks that none are visible.

And that's it for our first scenario. Relish hides away a lot of the details of the low-level interaction with the browser. Most the application-specific test code we've written has been in the =TaskPage= class, defining the expected functional structure of the page. 

Now we've spent a few minutes creating this test, we can go an implement the initial web page.

[[../images/notasks.png]]

* A second scenario: adding tasks

Our first scenario was obviously very simplistic. Now let's create a second, which requires a little more interactivity:

#+BEGIN_SRC feature
  Scenario: I can add a task
    Given I am on the task list
    When I choose to add these tasks
      | Name           |
      | Buy some bread |
      | Buy some milk  |
    Then I will see this on the list of tasks
      | Name           |
      | Buy some bread |
      | Buy some milk  |
#+END_SRC

Here we're using Cucumber feature-tables to specify the details of the tasks we going to add, and expect to the see on the application. Our scenario will begin by launching the app in the same way, but then will create a list of tasks, and check that they all appear on the front page as expected. 

We'll create each task with a second page containing a form that will allow us to enter the details of the task. When we save that task we'll return back to the front page of the application, where we should see our new task listed.

#+BEGIN_SRC ditaa :file ../images/add-design.png
        Task page                           Add task page
     +-----------------------+            +---------------+
     |                       |  Launches  |               |
     | New button -----------+----------->| New task form |
     |                       |            |               |
     |  Task table           |            |               |
     |                       |            |               |
     |                       |            | Save button   |
     |                       |            |       |       |
     +-----------------------+            +-------+-------+
                ^                                 |
                |        Return to Tasks page     |
                +---------------------------------+
#+END_SRC

So we'll a button on the front page for adding a task:

[[../images/addtaskbutton.png]]

And we'll need a second page with a simple form for entering a task, with a "Save" button:

[[../images/addformpage.png]]

When we click on the 'Add task' button on the front page, it will launch the 'Add task page', where we can fill out the details for the task, click 'Save' and return to the front page, where our new task will appear.

** Implementing the 'When I choose to add these tasks' step

We'll first modify our =TaskPage= class, adding in a testing component for the 'Add task' button:

#+BEGIN_SRC java
  package com.example.components;

  import org.openqa.selenium.By;

  import uk.co.blackpepper.relish.selenide.Table;
  import uk.co.blackpepper.relish.selenide.Page;
  import uk.co.blackpepper.relish.selenide.SelenideWidget;

  public class TaskPage extends Page
  {
      public TaskPage()
      {
          super("/index.html");
      }

      public Table taskTable()
      {
          return new Table(By.className("tasks"), this);
      }

      public SelenideWidget addButton()
      {
          return new SelenideWidget(By.className("addButton"), this);
      }
  }
#+END_SRC

Our new =addButton()= method returns =SelenideWidget= Relish object. This is a generic component that represent some part of a web page that we can look at and click. 

We'll also need to create a class for our second page: the one for creating a new task. We'll this =AddTaskPage=:

#+BEGIN_SRC java
  package com.example.components;

  import uk.co.blackpepper.relish.selenide.InputText;
  import uk.co.blackpepper.relish.selenide.Page;
  import uk.co.blackpepper.relish.selenide.SelenideWidget;
  import uk.co.blackpepper.relish.selenide.Table;
  import org.openqa.selenium.By;

  public class AddTaskPage extends Page {
      public AddTaskPage() {
          super("/add.html");
      }

      public InputText name() {
          return new InputText(By.id("name"), this);
      }

      public SelenideWidget saveButton() {
          return new SelenideWidget(By.className("saveButton"), this);
      }
  }
#+END_SRC

This class will be used to interact with the 'Add task page', which it will expect to find at path =/add.html=. It will include a button with the class name "saveButton" (which we represent by a =SelenideWidget= object), and also an =InputText= component with id "name". =InputText= is another Relish component for interacting with text fields.

Now we that have our page objects structured in the way that we want, we now need to write a 'When I choose to add these tasks' step. Remember: this is what the step looks like in our scenario:

#+BEGIN_SRC feature
    When I choose to add these tasks
      | Name           |
      | Buy some bread |
      | Buy some milk  |
#+END_SRC

This step will need to be passed the contents of the data-table containing the details of our new tasks. We normally do this in a Relish test by specifying the table as a list of Relish =TableRow= objects:

#+BEGIN_SRC java
  @When("^I choose to add these tasks$")
  public void iChooseToAddTheseTasks(List<TableRow> tasks)
  {
  ....
  }
#+END_SRC

A =TableRow= is very similar to a =Map<String,String>= and it's designed specifically to interact with Relish components. You'll see how shortly.

Now that we've begun to create our step, we'll need to fill out the code. We'll loop through each of the =TableRow= objects from the table, and for each one:

# Click on the 'Add task' button on the front page
# Fill out 'Add task' form on the 'Add task' page
# Then click 'Save' to return to the front page

This is how this is done in Relish:

#+BEGIN_SRC java
    @When("^I choose to add these tasks$")
    public void iChooseToAddTheseTasks(List<TableRow> tasks)
    {
        for(TableRow task : tasks)
        {
            taskPage.addButton().click();
            addTaskPage.set(task);
            addTaskPage.saveButton().click();
        }
    }
#+END_SRC

Notice that we're assuming here we've created a =addTaskPage= object higher up in the class.

The =addButton()= and =saveButton()= components (like all =selenide-relish= widgets) have =click()= methods. The interesting line is =addTaskPage.set(task)=.

The =set()= method accepts a =TableRow= object and uses it to update all of the sub-components whose names match the columns in the =TableRow=. So because our table looks like this:

| Name           |
|----------------|
| Buy some bread |
| Buy some milk  |

The =set()= method will convert the (only) column "Name" into camel-case, and look for a =name()= method on the =AddTaskPage= object. In our case, this =name()= method returns an =InputText= field, and Relish will tell the the =InputText= component to type in the strings "Buy some bread" and "Buy some milk" on each of the occasions that it visits the page.

If there had been multiple columns in the feature table, Relish would have looked for a matching component for each of them, and entered the data into each of the fields in the form.

This is where we start to benefit from the testing components built in to Relish: a lot of the boring "glue" code that takes data from a Cucumber scenario and passes it through to Selenide is done for us.

** Implementing the 'Then I will see this on the list of tasks' step

Now we need to check that the tasks we entered in the previous step now appear on the list of tasks on the main screen:

#+BEGIN_SRC feature
    Then I will see this on the list of tasks
      | Name           |
      | Buy some bread |
      | Buy some milk  |
#+END_SRC

This is actually remarkably easy to implement, because we already have all the components in place in the =Page= objects:

#+BEGIN_SRC java
    @Then("^I will see this on the list of tasks$")
    public void iWillSeeThisOnTheListOfTasks(List<TableRow> tasks)
    {
        taskPage.taskTable().matches(tasks);
    }
#+END_SRC

This uses the =matches()= method of the =taskTable()= to assert that the table contains rows that match the detail of each =TableRow=. The =Table= object will handle all of the details of finding the column headings and matching them to the column names in the table. 

That completes the scenario. This is the current state of our =SomeSteps= class:

#+BEGIN_SRC java
  package com.example.steps;

  import com.example.components.AddTaskPage;
  import com.example.components.TaskPage;

  import uk.co.blackpepper.relish.core.TableRow;

  import java.util.List;

  import cucumber.api.java.en.Given;
  import cucumber.api.java.en.Then;
  import cucumber.api.java.en.When;

  public class SomeSteps
  {
      private TaskPage taskPage = new TaskPage();
      private AddTaskPage addTaskPage = new AddTaskPage();

      @Given("^I am on the task list$")
      public void iAmOnTheTaskList()
      {
          taskPage.launch();
      }

      @Then("^the list of tasks will be empty$")
      public void theListOfTasksWillBeEmpty()
      {
          taskPage.taskTable().assertEmpty();
      }

      @When("^I choose to add these tasks$")
      public void iChooseToAddTheseTasks(List<TableRow> tasks)
      {
          for(TableRow task : tasks)
          {
              taskPage.addButton().click();
              addTaskPage.set(task);
              addTaskPage.saveButton().click();
          }
      }

      @Then("^I will see this on the list of tasks$")
      public void iWillSeeThisOnTheListOfTasks(List<TableRow> tasks)
      {
          taskPage.taskTable().matches(tasks);
      }
  }
#+END_SRC
* A third scenario: deleting tasks with interactive tables

For our third scenario, we'll create a test that checks we can delete tasks. To do this, we'll allow the user to select a set of existing tasks, and then delete them:

[[../images/delete-tasks.png]]

#+BEGIN_SRC feature
  Scenario: Can delete tasks
    Given I am on the task list
    Then the delete button is disabled
    When I choose to add these tasks
      | Name           |
      | Buy some bread |
      | Buy some milk  |
      | Buy some water |
    And I will select these tasks
      | Name           | Select |
      | Buy some bread | true   |
      | Buy some milk  | false  |
      | Buy some water | true   |
    And I choose to delete the selected tasks
    Then I will see this on the list of tasks
      | Name          | Select |
      | Buy some milk | false  |
#+END_SRC

** Add a delete button and checkboxes to the page

It should be obvious what the first thing we need to do is: add the components to the =TaskPage= object. We'll need a delete button:

#+BEGIN_SRC java
package com.example.components;

import org.openqa.selenium.By;

import uk.co.blackpepper.relish.selenide.Table;
import uk.co.blackpepper.relish.selenide.Page;
import uk.co.blackpepper.relish.selenide.SelenideWidget;

public class TaskPage extends Page
{
    public TaskPage()
    {
        super("/index.html");
    }

    public Table taskTable()
    {
        return new Table(By.className("tasks"), this);
    }

    public SelenideWidget addButton()
    {
        return new SelenideWidget(By.className("addButton"), this);
    }

    public SelenideWidget deleteButton()
    {
        return new SelenideWidget(By.className("deleteButton"), this);
    }
}
#+END_SRC

But then there's something a little more complex that we need to do: to modify the =Table= object returned from =taskTable()= so that it has the ability to interact with the checkbox in the =Selected= column of each table row.

By default, each cell in a =Table= is a simple =SelenideWidget=. That means the table is able to look at the text inside the table-cell, but it can't treat it like a more complex component, like a checkbox.

To do that, we need to call the =withCellComponent(...)= method of the =Table= object. This allows us to construct a Relish component for any given column:

#+BEGIN_SRC java
  package com.example.components;

  import org.openqa.selenium.By;

  import uk.co.blackpepper.relish.selenide.Checkbox;
  import uk.co.blackpepper.relish.selenide.Table;
  import uk.co.blackpepper.relish.selenide.Page;

  public class TaskPage extends Page
  {
      public TaskPage()
      {
          super("/index.html");
      }

      public Table taskTable()
      {
          return new Table(By.className("tasks"), this)
              .withCellComponent("select", (tdCell) -> new Checkbox(tdCell.$("input"), this))
              ;
      }

      public SelenideWidget addButton()
      {
          return new SelenideWidget(By.className("addButton"), this);
      }

      public SelenideWidget deleteButton()
      {
          return new SelenideWidget(By.className("deleteButton"), this);
      }
  }
#+END_SRC

The =.withCellComponent(...)= line will automatically a =Checkbox= testing for the checkbox =input= element inside the =select= column.

** Implement the "delete tasks" steps

Let's take another look at our new scenario:

#+BEGIN_SRC feature
  Scenario: Can delete tasks
    Given I am on the task list
    Then the delete button is disabled
    When I choose to add these tasks
      | Name           |
      | Buy some bread |
      | Buy some milk  |
      | Buy some water |
    And I will select these tasks
      | Name           | Select |
      | Buy some bread | true   |
      | Buy some milk  | false  |
      | Buy some water | true   |
    And I choose to delete the selected tasks
    Then I will see this on the list of tasks
      | Name          | Select |
      | Buy some milk | false  |
#+END_SRC

We have already implemented a =Given I am on the task list= step. 

The code for the =Then the delete button is disabled= can call our new =deleteButton()= component:

#+BEGIN_SRC java
  @Then("^the delete button is disabled$")
  public void theDeleteButtonIsDisabled()
  {
      taskPage.deleteButton().assertDisabled();
  }
#+END_SRC

The =assertDisabled()= method will check that the button is disabled.

We have already implemented the =When I choose to add these tasks= step.

But we will need to write new code for =And I will select these tasks=. This step will need to interact with the =Checkbox= objects we just added to the =taskTable()= object.

Our step will use this data from the feature file:

| Name           | Select |
|----------------+--------|
| Buy some bread | true   |
| Buy some milk  | false  |
| Buy some water | true   |

There's something we need to think about before we implement this step: we need to update the checkboxes using the data in the =Select= column, but we *can't* update the data in the =Name= column, because it will just be static text on the page:

[[../images/delete-tasks.png]]

So what we'll do instead is get the step to split the table into two tables that are like this:

| Name           |
|----------------|
| Buy some bread |
| Buy some milk  |
| Buy some water |

| Select |
|--------|
| true   |
| false  |
| true   |

We'll use the data in the first table to check that the rows on the screen /match/ the data in the table, then we'll use the data in the second table to /set/ the checkboxes in the table.

How do we split the tables? Fortunately, the =TableRow= object has the ability to create new versions of itself, with some columns removed. For example, if a =TableRow= object called =row= has columns =height=, =weight=, =age= and =gender=, we can create a new =TableRow= object with =weight= and =gender= columns with =row.except("weight", "gender")=.

So if our origin feature table is called =tasks=, we can create a table just without the =Select= column with:

#+BEGIN_SRC java
tasks.stream().map(t -> t.except("select")).collect(Collectors.toList())
#+END_SRC

And a table without the =Name= column with:

#+BEGIN_SRC java
tasks.stream().map(t -> t.except("name")).collect(Collectors.toList())
#+END_SRC

We can then pass these two tables (or, rather, these lists of =TableRows=) to the components like this:

#+BEGIN_SRC java
  @When("^I will select these tasks$")
  public void iWillSelectTheseTasks(List<TableRow> tasks)
  {
      taskPage.taskTable().matches(tasks.stream().map(t -> t.except("select")).collect(Collectors.toList()));
      taskPage.taskTable().set(tasks.stream().map(t -> t.except("name")).collect(Collectors.toList()));
  }
#+END_SRC

That way our step will /check/ that the =name= cells match the data in our feature file, and it will /set/ the checkboxes according the =true= / =false= values given in the same table.

Finally, to implement the =And I choose to delete the selected tasks= step, we can simply call the =click()= method on the =tasksPage.deleteButton()= method.

That means our =SomeSteps.java= file currently looks like this:

#+BEGIN_SRC java
  package com.example.steps;

  import com.example.components.AddTaskPage;
  import com.example.components.TaskPage;

  import uk.co.blackpepper.relish.core.TableRow;

  import java.util.ArrayList;
  import java.util.List;
  import java.util.stream.Collectors;

  import cucumber.api.java.en.Given;
  import cucumber.api.java.en.Then;
  import cucumber.api.java.en.When;

  public class SomeSteps
  {
      private TaskPage taskPage = new TaskPage();
      private AddTaskPage addTaskPage = new AddTaskPage();
      private EditTaskPage editTaskPage = new EditTaskPage();

      @Given("^I am on the task list$")
      public void iAmOnTheTaskList()
      {
          taskPage.launch();
      }

      @Then("^the list of tasks will be empty$")
      public void theListOfTasksWillBeEmpty()
      {
          taskPage.taskTable().assertEmpty();
      }

      @When("^I choose to add these tasks$")
      public void iChooseToAddTheseTasks(List<TableRow> tasks)
      {
          for(TableRow task : tasks)
          {
              taskPage.addButton().click();
              addTaskPage.set(task);
              addTaskPage.saveButton().click();
          }
      }

      @Then("^I will see this on the list of tasks$")
      public void iWillSeeThisOnTheListOfTasks(List<TableRow> tasks)
      {
          taskPage.taskTable().matches(tasks);
      }

      @When("^I will select these tasks$")
      public void iWillSelectTheseTasks(List<TableRow> tasks)
      {
          taskPage.taskTable().matches(tasks.stream().map(t -> t.except("select")).collect(Collectors.toList()));
          taskPage.taskTable().set(tasks.stream().map(t -> t.except("name")).collect(Collectors.toList()));
      }

      @When("^I choose to delete the selected tasks$")
      public void iChooseToDeleteTheSelectedTasks()
      {
          taskPage.deleteButton().click();
      }

      @Then("^the delete button is disabled$")
      public void theDeleteButtonIsDisabled()
      {
          taskPage.deleteButton().assertDisabled();
      }
  }
#+END_SRC
* A fourth scenario: editing tasks and using table columns without headings

Which brings us to the final scenario for this feature: editing tasks

#+BEGIN_SRC feature
  Scenario: Can edit a task
    Given I am on the task list
    When I choose to add these tasks
      | Name           |
      | Buy some bread |
      | Buy some milk  |
      | Buy some water |
    And I change the 'Buy some milk' task to
      | Name | Buy some cream |
    Then I will see this on the list of tasks
      | Name           |
      | Buy some bread |
      | Buy some cream |
      | Buy some water |
#+END_SRC

We'll need a new page for editing tasks. It will be virtually identical to to the =AddTaskPage=:

[[../images/edit-task.png]]

#+BEGIN_SRC java
  package com.example.components;

  import org.openqa.selenium.By;

  import uk.co.blackpepper.relish.selenide.InputText;
  import uk.co.blackpepper.relish.selenide.Page;
  import uk.co.blackpepper.relish.selenide.SelenideWidget;

  public class EditTaskPage extends Page {
      public EditTaskPage() {
          super("/edit.html");
      }

      public InputText name() {
          return new InputText(By.id("name"), this);
      }

      public SelenideWidget saveButton() {
          return new SelenideWidget(By.className("saveButton"), this);
      }
  }
#+END_SRC

But this is the design for the "Edit" button on the front screen:

[[../images/edit-button-on-list.png]]

In this design, the column containing the "Edit" buttons does not have a heading. How do we refer to that column?

By default, a column without a heading if given a virtual heading that matches the number of the column, starting at zero. That means we can update the =taskTable()= to be aware of the "Edit" button like this:

#+BEGIN_SRC java
  public Table taskTable()
  {
      return new Table(By.className("tasks"), this)
          .withCellComponent("select", (tdCell) -> new Checkbox(tdCell.$("input"), this))
          .withCellComponent("2", (tdCell) -> new SelenideWidget(tdCell.$("button"), this))
          ;
  }
#+END_SRC

The only step we need to implement for our "Edit" scenario is this one:

#+BEGIN_SRC feature
  And I change the 'Buy some milk' task to
  | Name | Buy some cream |
#+END_SRC

That means we need a way to access the edit button for the row with name =Buy some milk=. We can do that with a method on =Table= called =findFirst(...)=:

#+BEGIN_SRC java
taskPage.taskTable().findFirst("name", "Buy some milk")
#+END_SRC

This will return a Relish =HtmlRow= test component for the first row it finds with the correct name. The =HtmlRow= has a method called =getWidget(...)= which gives us access to the component for a single cell, either by passing a name, or a column number. That means we can click on the edit button for the =Buy some milk= row with this:

#+BEGIN_SRC java
taskPage.taskTable().findFirst("name", "Buy some milk").getWidget(2).click();
#+END_SRC

Adding this to a full implementation of the step, brings us to this version of the =SomeSteps.java= file:

#+BEGIN_SRC java
  package com.example.steps;

  import com.example.components.AddTaskPage;
  import com.example.components.EditTaskPage;
  import com.example.components.TaskPage;

  import uk.co.blackpepper.relish.core.TableRow;

  import java.util.List;
  import java.util.stream.Collectors;

  import cucumber.api.Transpose;
  import cucumber.api.java.en.Given;
  import cucumber.api.java.en.Then;
  import cucumber.api.java.en.When;

  public class SomeSteps
  {
      private TaskPage taskPage = new TaskPage();
      private AddTaskPage addTaskPage = new AddTaskPage();
      private EditTaskPage editTaskPage = new EditTaskPage();

      @Given("^I am on the task list$")
      public void iAmOnTheTaskList()
      {
          taskPage.launch();
      }

      @Then("^the list of tasks will be empty$")
      public void theListOfTasksWillBeEmpty()
      {
          taskPage.taskTable().assertEmpty();
      }

      @When("^I choose to add these tasks$")
      public void iChooseToAddTheseTasks(List<TableRow> tasks)
      {
          for(TableRow task : tasks)
              {
                  taskPage.addButton().click();
                  addTaskPage.set(task);
                  addTaskPage.saveButton().click();
              }
      }

      @Then("^I will see this on the list of tasks$")
      public void iWillSeeThisOnTheListOfTasks(List<TableRow> tasks)
      {
          taskPage.taskTable().matches(tasks);
      }

      @When("^I will select these tasks$")
      public void iWillSelectTheseTasks(List<TableRow> tasks)
      {
          taskPage.taskTable().matches(tasks.stream().map(t -> t.except("select")).collect(Collectors.toList()));
          taskPage.taskTable().set(tasks.stream().map(t -> t.except("name")).collect(Collectors.toList()));
      }

      @When("^I choose to delete the selected tasks$")
      public void iChooseToDeleteTheSelectedTasks()
      {
          taskPage.deleteButton().click();
      }

      @Then("^the delete button is disabled$")
      public void theDeleteButtonIsDisabled()
      {
          taskPage.deleteButton().assertDisabled();
      }

      @When("^I change the '([^']*)' task to$")
      public void iChangeTheTaskTo(String name, @Transpose List<TableRow> task)
      {
          taskPage.taskTable().findFirst("name", name).getWidget(2).click();
          editTaskPage.set(task.get(0));
          editTaskPage.saveButton().click();
      }
  }
#+END_SRC
